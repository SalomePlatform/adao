<?xml version='1.0' encoding='iso-8859-1' ?>
<!--
  Copyright (C) 2010-2012 EDF R&D

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

  See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
  
  Author: Jean-Philippe Argaud, jean-philippe.argaud@edf.fr, EDF R&D
-->
<proc>

  <objref name="computeAD" id="python:computeAD:1.0">
    <base>pyobj</base>
  </objref>

  <!-- Types for parametric computations -->
  <!-- TODO On devrait pouvoir le lire depuis le KERNEL !!!-->
  <type name="long" kind="int"/>
  <struct name="SALOME_TYPES/Parameter">
    <member type="string" name="name"></member>
    <member type="string" name="value"></member>
  </struct>
  <sequence content="SALOME_TYPES/Parameter" name="SALOME_TYPES/ParameterList"></sequence>
  <sequence content="double" name="SALOME_TYPES/Variable"></sequence>
  <sequence content="SALOME_TYPES/Variable" name="SALOME_TYPES/VariableSequence"></sequence>
  <sequence content="SALOME_TYPES/VariableSequence" name="SALOME_TYPES/StateSequence"></sequence>
  <sequence content="SALOME_TYPES/StateSequence" name="SALOME_TYPES/TimeSequence"></sequence>
  <sequence content="string" name="SALOME_TYPES/VarList"></sequence>
  <struct name="SALOME_TYPES/ParametricInput">
    <member type="SALOME_TYPES/VarList" name="inputVarList"></member>
    <member type="SALOME_TYPES/VarList" name="outputVarList"></member>
    <member type="SALOME_TYPES/TimeSequence" name="inputValues"></member>
    <member type="SALOME_TYPES/ParameterList" name="specificParameters"></member>
  </struct>
  <struct name="SALOME_TYPES/ParametricOutput">
    <member type="SALOME_TYPES/TimeSequence" name="outputValues"></member>
    <member type="SALOME_TYPES/ParameterList" name="specificOutputInfos"></member>
    <member type="long" name="returnCode"></member>
    <member type="string" name="errorMessage"></member>
  </struct>


  <inline name="CreateAssimilationStudy">
    <script><code>

<![CDATA[
import numpy, logging
logging.debug("CREATE Entering in CreateAssimilationStudy")
print "Entering in the assimilation study"
print "Name is set to........:", Name
print "Algorithm is set to...:", Algorithm
print "Debug is set to.......:", Debug

# Create Assimilation study
from daYacsIntegration.daStudy import *
assim_study = daStudy(Name, Algorithm, Debug)

# Algorithm parameters
try:
  AlgorithmParameters
except NameError:
  pass
else:
  assim_study.setAlgorithmParameters(AlgorithmParameters)

logging.debug("CREATE Data entered are:")

# Background
try:
  Background
except NameError:
  pass
else:
  logging.debug("CREATE Background is set")
  logging.debug("CREATE BackgroundType is %s"%BackgroundType)
  logging.debug("CREATE BackgroundStored is %s"%BackgroundStored)
  assim_study.setBackgroundType(BackgroundType)
  assim_study.setBackgroundStored(BackgroundStored)
  assim_study.setBackground(Background)

# CheckingPoint
try:
  CheckingPoint
except NameError:
  pass
else:
  logging.debug("CREATE CheckingPoint is set")
  logging.debug("CREATE CheckingPointType is %s"%CheckingPointType)
  logging.debug("CREATE CheckingPointStored is %s"%CheckingPointStored)
  assim_study.setCheckingPointType(CheckingPointType)
  assim_study.setCheckingPointStored(CheckingPointStored)
  assim_study.setCheckingPoint(CheckingPoint)

# BackgroundError
try:
  BackgroundError
except NameError:
  pass
else:
  logging.debug("CREATE BackgroundError is set")
  logging.debug("CREATE BackgroundErrorStored is %s"%BackgroundErrorStored)
  assim_study.setBackgroundErrorStored(BackgroundErrorStored)
  assim_study.setBackgroundError(BackgroundError)

# Observation
try:
  Observation
except NameError:
  pass
else:
  logging.debug("CREATE Observation is set")
  logging.debug("CREATE ObservationType is %s"%ObservationType)
  logging.debug("CREATE ObservationStored is %s"%ObservationStored)
  assim_study.setObservationType(ObservationType)
  assim_study.setObservationStored(ObservationStored)
  assim_study.setObservation(Observation)

# ObservationError
try:
  ObservationError
except NameError:
  pass
else:
  logging.debug("CREATE ObservationError is set")
  logging.debug("CREATE ObservationErrorStored is %s"%ObservationErrorStored)
  assim_study.setObservationErrorStored(ObservationErrorStored)
  assim_study.setObservationError(ObservationError)

# EvolutionError
try:
  EvolutionError
except NameError:
  pass
else:
  logging.debug("CREATE EvolutionError is set")
  logging.debug("CREATE EvolutionErrorStored is %s"%EvolutionErrorStored)
  assim_study.setEvolutionErrorStored(EvolutionErrorStored)
  assim_study.setEvolutionError(EvolutionError)

# ObservationOperator
ObservationOperatorOk = 0
try:
  ObservationOperator
except NameError:
  pass
else:
  logging.debug("CREATE ObservationOperator is set")
  logging.debug("CREATE ObservationOperatorType is %s"%ObservationOperatorType)
  assim_study.setObservationOperatorType("Matrix", ObservationOperatorType)
  assim_study.setObservationOperator("Matrix", ObservationOperator)
  ObservationOperatorOk = 1

if ObservationOperatorOk == 0:
  try:
    ObservationOperatorDirect
  except NameError:
    pass
  else:
    logging.debug("CREATE ObservationOperatorDirect is %s"%ObservationOperatorDirect)
    assim_study.setObservationOperatorType("Direct", "Function")
    assim_study.setObservationOperator("Direct", ObservationOperatorDirect)
  try:
    ObservationOperatorTangent
  except NameError:
    pass
  else:
    logging.debug("CREATE ObservationOperatorTangent is %s"%ObservationOperatorTangent)
    assim_study.setObservationOperatorType("Tangent", "Function")
    assim_study.setObservationOperator("Tangent", ObservationOperatorTangent)
  try:
    ObservationOperatorAdjoint
  except NameError:
    pass
  else:
    logging.debug("CREATE ObservationOperatorAdjoint is %s"%ObservationOperatorAdjoint)
    assim_study.setObservationOperatorType("Adjoint", "Function")
    assim_study.setObservationOperator("Adjoint", ObservationOperatorAdjoint)

# EvolutionModel
EvolutionModelOk = 0
try:
  EvolutionModel
except NameError:
  pass
else:
  logging.debug("CREATE EvolutionModel is set")
  logging.debug("CREATE EvolutionModelType is %s"%EvolutionModelType)
  assim_study.setEvolutionModelType("Matrix", EvolutionModelType)
  assim_study.setEvolutionModel("Matrix", EvolutionModel)
  EvolutionModelOk = 1

if EvolutionModelOk == 0:
  try:
    EvolutionModelDirect
  except NameError:
    pass
  else:
    logging.debug("CREATE EvolutionModelDirect is %s"%EvolutionModelDirect)
    assim_study.setEvolutionModelType("Direct", "Function")
    assim_study.setEvolutionModel("Direct", EvolutionModelDirect)
  try:
    EvolutionModelTangent
  except NameError:
    pass
  else:
    logging.debug("CREATE EvolutionModelTangent is %s"%EvolutionModelTangent)
    assim_study.setEvolutionModelType("Tangent", "Function")
    assim_study.setEvolutionModel("Tangent", EvolutionModelTangent)
  try:
    EvolutionModelAdjoint
  except NameError:
    pass
  else:
    logging.debug("CREATE EvolutionModelAdjoint is %s"%EvolutionModelAdjoint)
    assim_study.setEvolutionModelType("Adjoint", "Function")
    assim_study.setEvolutionModel("Adjoint", EvolutionModelAdjoint)

# Variables
for name, size in zip(InputVariablesNames, InputVariablesSizes):
  assim_study.setInputVariable(name, size)
for name, size in zip(OutputVariablesNames, OutputVariablesSizes):
  assim_study.setOutputVariable(name, size)

if has_observers:
  logging.debug("CREATE Observers keys are %s"%observers.keys())
  # Adding observers to the study
  for observer_name in observers.keys():
    scheduler = ""
    info = ""
    number = str(observers[observer_name]["number"])
    if "scheduler" in observers[observer_name].keys():
      scheduler = observers[observer_name]["scheduler"]
    if "info" in observers[observer_name].keys():
      info = observers[observer_name]["info"]
    assim_study.addObserver(observer_name, scheduler, info, number)
Study = assim_study
]]>

</code></script>
    <inport name="Name" type="string"/>
    <inport name="Algorithm" type="string"/>
    <inport name="Debug" type="bool"/>
    <inport name="InputVariablesNames" type="stringvec"/>
    <inport name="InputVariablesSizes" type="intvec"/>
    <inport name="OutputVariablesNames" type="stringvec"/>
    <inport name="OutputVariablesSizes" type="intvec"/>
    <inport name="has_observers" type="bool"/>
    <inport name="observers" type="pyobj"/>
    <outport name="Study" type="pyobj"/>
  </inline>

  <inline name="CreateNumpyMatrixFromString">
    <script><code><![CDATA[
import numpy, logging
logging.debug("CREATE Entering in CreateNumpyMatrixFromString")
matrix = numpy.matrix(matrix_in_string)
type = "Matrix"
logging.debug("CREATE Matrix is %s"%matrix)
]]></code></script>
    <inport name="matrix_in_string" type="string"/>
    <outport name="matrix" type="pyobj"/>
    <outport name="type" type="string"/>
    <outport name="stored" type="bool"/>
  </inline>

  <inline name="CreateNumpyMatrixFromScript">
    <script><code><![CDATA[
import logging
logging.debug("CREATE Entering in CreateNumpyMatrixFromScript")
type = "Matrix"

# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
if sys.path.count(filepath)==0 or (sys.path.count(filepath)>0 and sys.path.index(filepath)>0):
    sys.path.insert(0,filepath)

# Import script
__import__(module_name)
user_script_module = sys.modules[module_name]

# Get Data from script
]]></code></script>
    <inport name="script" type="string"/>
    <outport name="type" type="string"/>
    <outport name="stored" type="bool"/>
  </inline>

  <inline name="CreateNumpyVectorFromString">
    <script><code><![CDATA[
import numpy, logging
logging.debug("CREATE Entering in CreateNumpyVectorFromString")
vector = numpy.matrix(vector_in_string)
type = "Vector"
logging.debug("Vector is %s"%vector)
]]></code></script>
    <inport name="vector_in_string" type="string"/>
    <outport name="vector" type="pyobj"/>
    <outport name="type" type="string"/>
    <outport name="stored" type="bool"/>
  </inline>

  <inline name="CreateNumpyVectorFromScript">
    <script><code><![CDATA[
import logging
logging.debug("CREATE Entering in CreateNumpyVectorFromScript")
type = "Vector"

# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
if sys.path.count(filepath)==0 or (sys.path.count(filepath)>0 and sys.path.index(filepath)>0):
    sys.path.insert(0,filepath)

# Import script
__import__(module_name)
user_script_module = sys.modules[module_name]

# Get Data from script
]]></code></script>
    <inport name="script" type="string"/>
    <outport name="type" type="string"/>
    <outport name="stored" type="bool"/>
  </inline>

  <inline name="CreateNumpyVectorSerieFromString">
    <script><code><![CDATA[
import numpy, logging
logging.debug("CREATE Entering in CreateNumpyVectorSerieFromString")
vector = numpy.matrix(vector_in_string)
type = "VectorSerie"
logging.debug("VectorSerie is %s"%vector)
]]></code></script>
    <inport name="vector_in_string" type="string"/>
    <outport name="vector" type="pyobj"/>
    <outport name="type" type="string"/>
    <outport name="stored" type="bool"/>
  </inline>

  <inline name="CreateNumpyVectorSerieFromScript">
    <script><code><![CDATA[
import logging
logging.debug("CREATE Entering in CreateNumpyVectorSerieFromScript")
type = "VectorSerie"

# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
if sys.path.count(filepath)==0 or (sys.path.count(filepath)>0 and sys.path.index(filepath)>0):
    sys.path.insert(0,filepath)

# Import script
__import__(module_name)
user_script_module = sys.modules[module_name]

# Get Data from script
]]></code></script>
    <inport name="script" type="string"/>
    <outport name="type" type="string"/>
    <outport name="stored" type="bool"/>
  </inline>

  <inline name="SimpleExecuteDirectAlgorithm">
    <script><code><![CDATA[
import logging
logging.debug("EXECUTE Entering in SimpleExecuteDirectAlgorithm")
from daYacsIntegration.daStudy import *
ADD = Study.getAssimilationStudy()
ADD.analyze()
]]></code></script>
    <inport name="Study" type="pyobj"/>
    <outport name="Study" type="pyobj"/>
  </inline>

  <inline name="SimpleUserAnalysis">
    <script><code><![CDATA[
#-*-coding:iso-8859-1-*-
import logging
logging.debug("TERMINATE Entering in SimpleUserAnalysis")
from daYacsIntegration.daStudy import *
ADD = Study.getAssimilationStudy()
# User code is below

]]></code></script>
    <inport name="Study" type="pyobj"/>
  </inline>

  <inline name="FakeOptimizerLoopNode">
    <script><code><![CDATA[
import logging
logging.debug("EXECUTE Entering in FakeOptimizerLoopNode")
result = None
]]></code></script>
    <inport name="computation" type="SALOME_TYPES/ParametricInput"/>
    <outport name="result" type="SALOME_TYPES/ParametricOutput"/>
  </inline>

  <inline name="CreateDictFromScript">
    <script><code><![CDATA[
import logging
logging.debug("CREATE Entering in CreateDictFromScript")

# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
if sys.path.count(filepath)==0 or (sys.path.count(filepath)>0 and sys.path.index(filepath)>0):
    sys.path.insert(0,filepath)

# Import script
__import__(module_name)
user_script_module = sys.modules[module_name]

# Get Data from script
]]></code></script>
    <inport name="script" type="string"/>
  </inline>

  <inline name="UserDataInitFromScript">
    <script><code><![CDATA[
import logging
logging.debug("CREATE Entering in UserDataInitFromScript")

# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
if sys.path.count(filepath)==0 or (sys.path.count(filepath)>0 and sys.path.index(filepath)>0):
    sys.path.insert(0,filepath)

# Import script
__import__(module_name)
user_script_module = sys.modules[module_name]

# Get Data from script
]]></code></script>
    <inport name="script" type="string"/>
    <outport name="init_data" type="pyobj"/>
  </inline>

  <inline name="ReadForSwitchNode">
    <script><code><![CDATA[
import logging
logging.debug("CREATE Entering in ReadForSwitchNode")
logging.debug("       with input data : "+str(data["specificParameters"]))
switch_value = -1
for param in data["specificParameters"]:
  if param["name"] == "switch_value":
    switch_value = int(param["value"])
logging.debug("       switching to value : "+str(switch_value))
]]></code></script>
    <inport name="data" type="SALOME_TYPES/ParametricInput"/>
    <outport name="data" type="SALOME_TYPES/ParametricInput"/>
    <outport name="switch_value" type="int"/>
  </inline>

  <inline name="ExtractDataNode">
    <script><code><![CDATA[
import logging
logging.debug("TERMINATE Entering in ExtractDataNode")
import cPickle
from daCore.AssimilationStudy import AssimilationStudy
var = None
info = None
for param in data["specificParameters"]:
  if param["name"] == "var":
    var = cPickle.loads(param["value"])
  if param["name"] == "info":
    info = param["value"]
]]></code></script>
    <inport name="data" type="SALOME_TYPES/ParametricInput"/>
    <outport name="var" type="pyobj"/>
    <outport name="info" type="pyobj"/>
  </inline>

  <inline name="ObservationNodeString">
    <script><code><![CDATA[
#print "Entering in Observation"

]]></code></script>
    <inport name="var" type="pyobj"/>
    <inport name="info" type="pyobj"/>
  </inline>

  <inline name="ObservationNodeFile">
    <script><code><![CDATA[
#print "Entering in Observation"
execfile(script)

]]></code></script>
    <inport name="var"    type="pyobj"/>
    <inport name="info"   type="pyobj"/>
    <inport name="script" type="string"/>
  </inline>

  <inline name="EndObservationNode">
    <script><code><![CDATA[
# Create a fake output object.
# An observer is always successful.
output = {}
output["outputValues"]        = [[[[]]]]
output["specificOutputInfos"] = []
output["returnCode"]          = 0
output["errorMessage"]        = ""
]]></code></script>
    <outport name="output" type="SALOME_TYPES/ParametricOutput"/>
  </inline>

  <inline name="SetObserversNode">
    <script><code><![CDATA[
#print "Setting observers"
]]></code></script>
    <outport name="has_observers" type="bool"/>
    <outport name="observers" type="pyobj"/>
  </inline>
</proc>
