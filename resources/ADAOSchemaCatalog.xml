<?xml version='1.0' encoding='iso-8859-1' ?>
<!--
  Copyright (C) 2010-2011 EDF R&D

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

  See http://www.salome-platform.org/ or email : webmaster.salome@opencascade.com
  
  Author: Andre Ribes, andre.ribes@edf.fr, EDF R&D
-->
<proc>

  <objref name="computeAD" id="python:computeAD:1.0">
    <base>pyobj</base>
  </objref>

  <!-- Types for parametric computations -->
  <!-- TODO On devrait pouvoir le lire depuis le KERNEL !!!-->
  <type name="long" kind="int"/>
  <struct name="SALOME_TYPES/Parameter">
    <member type="string" name="name"></member>
    <member type="string" name="value"></member>
  </struct>
  <sequence content="SALOME_TYPES/Parameter" name="SALOME_TYPES/ParameterList"></sequence>
  <sequence content="double" name="SALOME_TYPES/Variable"></sequence>
  <sequence content="SALOME_TYPES/Variable" name="SALOME_TYPES/VariableSequence"></sequence>
  <sequence content="SALOME_TYPES/VariableSequence" name="SALOME_TYPES/StateSequence"></sequence>
  <sequence content="SALOME_TYPES/StateSequence" name="SALOME_TYPES/TimeSequence"></sequence>
  <sequence content="string" name="SALOME_TYPES/VarList"></sequence>
  <struct name="SALOME_TYPES/ParametricInput">
    <member type="SALOME_TYPES/VarList" name="inputVarList"></member>
    <member type="SALOME_TYPES/VarList" name="outputVarList"></member>
    <member type="SALOME_TYPES/TimeSequence" name="inputValues"></member>
    <member type="SALOME_TYPES/ParameterList" name="specificParameters"></member>
  </struct>
  <struct name="SALOME_TYPES/ParametricOutput">
    <member type="SALOME_TYPES/TimeSequence" name="outputValues"></member>
    <member type="SALOME_TYPES/ParameterList" name="specificOutputInfos"></member>
    <member type="long" name="returnCode"></member>
    <member type="string" name="errorMessage"></member>
  </struct>


  <inline name="CreateAssimilationStudy">
    <script><code>

<![CDATA[
import numpy
print "Entering in CreateAssimilationStudy"
print "Name is", Name
print "Algorithm is", Algorithm
print "Debug is set to", Debug

# Create Assimilation study
from daYacsIntegration.daStudy import *
assim_study = daStudy(Name, Algorithm, Debug)

# Algorithm parameters
try:
  AlgorithmParameters
except NameError:
  pass
else:
  assim_study.setAlgorithmParameters(AlgorithmParameters)

# Data
print "Data entered are:"
# Background
try:
  Background
except NameError:
  pass
else:
  #print "Background is", Background
  #print "BackgroundType is", BackgroundType
  assim_study.setBackgroundType(BackgroundType)
  assim_study.setBackground(Background)

# BackgroundError
try:
  BackgroundError
except NameError:
  pass
else:
  #print "BackgroundError is", BackgroundError
  #print "BackgroundErrorType is", BackgroundErrorType
  assim_study.setBackgroundError(BackgroundError)

# Observation
try:
  Observation
except NameError:
  pass
else:
  #print "Observation is", Observation
  #print "ObservationType is", ObservationType
  assim_study.setObservationType(ObservationType)
  assim_study.setObservation(Observation)

# ObservationError
try:
  ObservationError
except NameError:
  pass
else:
  #print "ObservationError is", ObservationError
  #print "ObservationErrorType is", ObservationErrorType
  assim_study.setObservationError(ObservationError)

# ObservationOperator
ObservationOperatorOk = 0
try:
  ObservationOperator
except NameError:
  pass
else:
  #print "ObservationOperator is", ObservationOperator
  #print "ObservationOperatorType is", ObservationOperatorType
  assim_study.setObservationOperatorType("Matrix", ObservationOperatorType)
  assim_study.setObservationOperator("Matrix", ObservationOperator)
  ObservationOperatorOk = 1

if ObservationOperatorOk == 0:
  try:
    ObservationOperatorDirect
  except NameError:
    pass
  else:
    #print "ObservationOperatorDirect is", ObservationOperatorDirect
    assim_study.setObservationOperatorType("Direct", "Function")
    assim_study.setObservationOperator("Direct", ObservationOperatorDirect)
  try:
    ObservationOperatorTangent
  except NameError:
    pass
  else:
    #print "ObservationOperatorTangent is", ObservationOperatorTangent
    assim_study.setObservationOperatorType("Tangent", "Function")
    assim_study.setObservationOperator("Tangent", ObservationOperatorTangent)
  try:
    ObservationOperatorAdjoint
  except NameError:
    pass
  else:
    #print "ObservationOperatorAdjoint is", ObservationOperatorAdjoint
    assim_study.setObservationOperatorType("Adjoint", "Function")
    assim_study.setObservationOperator("Adjoint", ObservationOperatorAdjoint)

# Variables
for name, size in zip(InputVariablesNames, InputVariablesSizes):
  assim_study.setInputVariable(name, size)
for name, size in zip(OutputVariablesNames, OutputVariablesSizes):
  assim_study.setOutputVariable(name, size)

Study = assim_study
]]>

</code></script>
    <inport name="Name" type="string"/>
    <inport name="Algorithm" type="string"/>
    <inport name="Debug" type="bool"/>
    <inport name="InputVariablesNames" type="stringvec"/>
    <inport name="InputVariablesSizes" type="intvec"/>
    <inport name="OutputVariablesNames" type="stringvec"/>
    <inport name="OutputVariablesSizes" type="intvec"/>
    <inport name="has_observers" type="bool"/>
    <inport name="observers" type="pyobj"/>
    <outport name="Study" type="pyobj"/>
  </inline>

  <inline name="CreateNumpyMatrixFromString">
    <script><code><![CDATA[
print "Entering in CreateNumpyMatrixFromString"
import numpy
matrix = numpy.matrix(matrix_in_string)
type = "Matrix"
print "Matrix is", matrix
]]></code></script>
    <inport name="matrix_in_string" type="string"/>
    <outport name="matrix" type="pyobj"/>
    <outport name="type" type="string"/>
  </inline>

  <inline name="CreateNumpyMatrixFromScript">
    <script><code><![CDATA[
print "Entering in CreateNumpyMatrixFromScript"
type = "Matrix"

# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
sys.path.insert(0,filepath)

# Import script
__import__(module_name)
user_script_module = sys.modules[module_name]

# Get Data from script
]]></code></script>
    <inport name="script" type="string"/>
    <outport name="type" type="string"/>
  </inline>

  <inline name="CreateNumpyVectorFromString">
    <script><code><![CDATA[
print "Entering in CreateNumpyVectorFromString"
import numpy
vector = numpy.matrix(vector_in_string)
type = "Vector"
print "Vector is", vector
]]></code></script>
    <inport name="vector_in_string" type="string"/>
    <outport name="vector" type="pyobj"/>
    <outport name="type" type="string"/>
  </inline>

  <inline name="CreateNumpyVectorFromScript">
    <script><code><![CDATA[
print "Entering in CreateNumpyVectorFromScript"
type = "Vector"

# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
sys.path.insert(0,filepath)

# Import script
__import__(module_name)
user_script_module = sys.modules[module_name]

# Get Data from script
]]></code></script>
    <inport name="script" type="string"/>
    <outport name="type" type="string"/>
  </inline>

  <inline name="SimpleExecuteDirectAlgorithm">
    <script><code><![CDATA[
print "Entering in SimpleExecuteDirectAlgorithm"
from daYacsIntegration.daStudy import *
ADD = Study.getAssimilationStudy()
ADD.analyze()
]]></code></script>
    <inport name="Study" type="pyobj"/>
    <outport name="Study" type="pyobj"/>
  </inline>

  <inline name="SimpleUserAnalysis">
    <script><code><![CDATA[
#-*-coding:iso-8859-1-*-
print "Entering in SimpleUserAnalysis"
from daYacsIntegration.daStudy import *
ADD = Study.getAssimilationStudy()
# User code is below

]]></code></script>
    <inport name="Study" type="pyobj"/>
  </inline>

  <inline name="FakeOptimizerLoopNode">
    <script><code><![CDATA[
print "Entering in FakeOptimizerLoopNode"
result = None
]]></code></script>
    <inport name="computation" type="SALOME_TYPES/ParametricInput"/>
    <outport name="result" type="SALOME_TYPES/ParametricOutput"/>
  </inline>

  <inline name="CreateDictFromScript">
    <script><code><![CDATA[
print "Entering in CreateDictFromScript"

# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
sys.path.insert(0,filepath)

# Import script
__import__(module_name)
user_script_module = sys.modules[module_name]

# Get Data from script
]]></code></script>
    <inport name="script" type="string"/>
  </inline>

  <inline name="UserDataInitFromScript">
    <script><code><![CDATA[
print "Entering in UserDataInitFromScript"

# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
sys.path.insert(0,filepath)

# Import script
__import__(module_name)
user_script_module = sys.modules[module_name]

# Get Data from script
]]></code></script>
    <inport name="script" type="string"/>
    <outport name="init_data" type="pyobj"/>
  </inline>

  <inline name="ReadForSwitchNode">
    <script><code><![CDATA[
print "Entering in ReadForSwitch"
switch_value = -1
for param in data["specificParameters"]:
  if param["name"] == "switch_value":
    switch_value = int(param["value"])
]]></code></script>
    <inport name="data" type="SALOME_TYPES/ParametricInput"/>
    <outport name="data" type="SALOME_TYPES/ParametricInput"/>
    <outport name="switch_value" type="int"/>
  </inline>

  <inline name="ExtractDataNode">
    <script><code><![CDATA[
import pickle
print "Entering in ExtractData"
var = None
info = None
for param in data["specificParameters"]:
  if param["name"] == "var":
    var = pickle.loads(param["value"])
  if param["name"] == "info":
    info = pickle.loads(param["value"])
]]></code></script>
    <inport name="data" type="SALOME_TYPES/ParametricInput"/>
    <outport name="var" type="pyobj"/>
    <outport name="info" type="pyobj"/>
  </inline>

  <inline name="ObservationNodeString">
    <script><code><![CDATA[
print "Entering in Observation"

]]></code></script>
    <inport name="var" type="pyobj"/>
    <inport name="info" type="pyobj"/>
  </inline>

  <inline name="ObservationNodeFile">
    <script><code><![CDATA[
print "Entering in Observation"
# Get file path and filename
import sys
import os
filepath = os.path.dirname(script)
filename = os.path.basename(script)
module_name = os.path.splitext(filename)[0]
sys.path.insert(0,filepath)
# Import script
__import__(module_name)

]]></code></script>
    <inport name="var"    type="pyobj"/>
    <inport name="info"   type="pyobj"/>
    <inport name="script" type="string"/>
  </inline>

  <inline name="EndObservationNode">
    <script><code><![CDATA[
# Create a fake output object.
# An observer is always successful.
output = {}
output["outputValues"]        = [[[[]]]]
output["specificOutputInfos"] = []
output["returnCode"]          = 0
output["errorMessage"]        = ""
]]></code></script>
    <outport name="output" type="SALOME_TYPES/ParametricOutput"/>
  </inline>

  <inline name="SetObserversNode">
    <script><code><![CDATA[
print "Setting observers"
]]></code></script>
    <outport name="has_observers" type="bool"/>
    <outport name="observers" type="pyobj"/>
  </inline>
</proc>
