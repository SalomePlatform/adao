#-*-coding:iso-8859-1-*-
#
# Copyright (C) 2008-2013 EDF R&D
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
#
# Author: Jean-Philippe Argaud, jean-philippe.argaud@edf.fr, EDF R&D

import logging
import traceback
import sys
import string
import StringIO

import module_version

logging.basicConfig(level=logging.WARNING)

#----------- Templates Part ---------------#
begin_catalog_file = """# -*- coding: utf-8 -*-

# --------------------------------------------------------
# generated by AdaoCatalogGenerator at ${date}
# --------------------------------------------------------

import Accas
from Accas import *

JdC = JDC_CATA (code = '%s',
                execmodul = None,
                regles = ( AU_MOINS_UN ('ASSIMILATION_STUDY','CHECKING_STUDY'), AU_PLUS_UN ('ASSIMILATION_STUDY','CHECKING_STUDY')),
               )
VERSION_CATALOGUE='%s'
"""%(module_version.name,module_version.version)

data_method = """
def F_${data_name}(statut) : return FACT(statut = statut,
                                         FROM = SIMP(statut = "o", typ = "TXM", into=(${data_into}), defaut=${data_default}),
                                         SCRIPT_DATA = BLOC ( condition = " FROM in ( 'Script', ) ",

                                                      SCRIPT_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()), fr="En attente d'un nom de fichier script, avec ou sans le chemin complet pour le trouver, contenant si nécessaire la définition d'une variable interne de même nom que le concept parent", ang="Waiting for a script file name, with or without the full path to find it, containing if necessary the definition of an internal variable of the same name as the parent concept"),
                                                     ),
                                         STRING_DATA = BLOC ( condition = " FROM in ( 'String', ) ",

                                                      STRING = SIMP(statut = "o", typ = "TXM", fr="En attente d'une chaine de caractères entre guillements. Pour construire un vecteur ou une matrice, ce doit être une suite de nombres, utilisant un espace ou une virgule pour séparer deux éléments et un point-virgule pour séparer deux lignes", ang="Waiting for a string in quotes. To build a vector or a matrix, it has to be a float serie, using a space or comma to separate two elements in a line, a semi-colon to separate rows"),
                                                     ),
                                         SCRIPTWITHFUNCTIONS_DATA = BLOC ( condition = " FROM in ( 'ScriptWithFunctions', ) ",

                                                      SCRIPTWITHFUNCTIONS_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()), fr="En attente d'un nom de fichier script, avec ou sans le chemin complet pour le trouver, contenant en variables internes trois fonctions de calcul nommées DirectOperator, TangentOperator et AdjointOperator", ang="Waiting for a script file name, with or without the full path to find it, containing as internal variables three computation functions named DirectOperator, TangentOperator and AdjointOperator"),
                                                     ),
                                         SCRIPTWITHONEFUNCTION_DATA = BLOC ( condition = " FROM in ( 'ScriptWithOneFunction', ) ",

                                                      SCRIPTWITHONEFUNCTION_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()), fr="En attente d'un nom de fichier script, avec ou sans le chemin complet pour le trouver, contenant en variable interne une seule fonction de calcul nommée DirectOperator", ang="Waiting for a script file name, with or without the full path to find it, containing as internal variable only one function named DirectOperator"),
                                                      DifferentialIncrement = SIMP(statut="o", typ = "R", val_min=0, val_max=1, defaut=0.01, fr="Incrément de la perturbation dX pour calculer la dérivée, construite en multipliant X par l'incrément en évitant les valeurs nulles", ang="Increment of dX perturbation to calculate the derivative, build multiplying X by the increment avoiding null values"),
                                                      CenteredFiniteDifference = SIMP(statut="o", typ = "I", into=(0, 1), defaut=0, fr="Formulation centrée (1) ou décentrée (0) pour la méthode des différences finies", ang="Centered (1) or uncentered (0) formulation for the finite difference method"),
                                                     ),
                                         SCRIPTWITHSWITCH_DATA = BLOC ( condition = " FROM in ( 'ScriptWithSwitch', ) ",

                                                      SCRIPTWITHSWITCH_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()), fr="En attente d'un nom de fichier script, avec ou sans le chemin complet pour le trouver, contenant un switch pour les calculs direct, tangent et adjoint", ang="Waiting for a script file name, with or without the full path to find it, containing a switch for direct, tangent and adjoint computations"),
                                                     ),
                                         FUNCTIONDICT_DATA = BLOC ( condition = " FROM in ( 'FunctionDict', ) ",

                                                      FUNCTIONDICT_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()), fr="OBSOLETE : conservé pour compatibilité avec la version 6.5, sera supprimé dans le futur", ang="OBSOLETE: keeped for compatibility with the 6.5 version, will be removed in the future"),
                                                     ),
                                         TEMPLATE_DATA =  BLOC (condition = " FROM in ( 'Template', ) ",
                                             Template = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "AnalysisPrinter", into=("AnalysisPrinter", "AnalysisSaver", "AnalysisPrinterAndSaver")),
                                             AnalysisPrinter = BLOC (condition = " Template == 'AnalysisPrinter' ",
                                                 ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "import numpy\\nxa=numpy.ravel(ADD.get('Analysis')[-1])\\nprint 'Analysis:',xa" ),
                                             ),
                                             AnalysisSaver = BLOC (condition = " Template == 'AnalysisSaver' ",
                                                 ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "import numpy\\nxa=numpy.ravel(ADD.get('Analysis')[-1])\\nf='/tmp/analysis.txt'\\nprint 'Analysis saved in \\"%s\\"'%f\\nnumpy.savetxt(f,xa)" ),
                                             ),
                                             AnalysisPrinterAndSaver = BLOC (condition = " Template == 'AnalysisPrinterAndSaver' ",
                                                 ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "import numpy\\nxa=numpy.ravel(ADD.get('Analysis')[-1])\\nprint 'Analysis:',xa\\nf='/tmp/analysis.txt'\\nprint 'Analysis saved in \\"%s\\"'%f\\nnumpy.savetxt(f,xa)" ),
                                             ),
                                         ),
                                    )
"""

init_method = """
def F_InitChoice() : return  ("Background",
                              "BackgroundError",
                              "Observation",
                              "ObservationError",
                              "ObservationOperator",
                              "EvolutionModel",
                              "EvolutionError",
                              "AlgorithmParameters",
                              "UserPostAnalysis",
                             )

def F_Init(statut) : return FACT(statut = statut,
                                 INIT_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr())),
                                 TARGET_LIST = SIMP(statut = "o", typ = "TXM", min=1, max="**", into=F_InitChoice(),  validators=(VerifExiste(2))),
                                )
"""

assim_data_method = """
def F_${assim_name}(statut) : return FACT(statut=statut,
${storage}
                                          INPUT_TYPE = SIMP(statut="o", typ = "TXM", into=(${choices}), defaut=${default_choice}),
${decl_choices}
                                                )
"""

assim_data_choice = """
                                                 ${choice_name} = BLOC ( condition = " INPUT_TYPE in ( '${choice_name}', ) ",
                                                 data = F_${choice_name}("o"),
                                                 ),
"""

observers_choice = """
                                       ${var_name} = BLOC (condition=" '${var_name}' in set(SELECTION) ",
                                           ${var_name}_data = FACT(statut = "o",
                                               Scheduler    = SIMP(statut = "f", typ = "TXM"),
                                               Info         = SIMP(statut = "o", typ = "TXM", defaut = "${var_name}"),
                                               NodeType     = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "Template", into=("String", "Script", "Template")),
                                               PythonScript = BLOC (condition = " NodeType == 'String' ",
                                                   Value = SIMP(statut = "o", typ = "TXM")
                                               ),
                                               UserFile = BLOC (condition = " NodeType == 'Script' ",
                                                   Value = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()))
                                               ),
                                               ObserverTemplate =  BLOC (condition = " NodeType == 'Template' ",
                                                   Template = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "ValuePrinter", into=("ValuePrinter", "ValueSeriePrinter", "ValueSaver", "ValueSerieSaver", "ValuePrinterAndSaver", "ValueSeriePrinterAndSaver", "ValueGnuPlotter", "ValueSerieGnuPlotter")),
                                                   ValuePrinter = BLOC (condition = " Template == 'ValuePrinter' ",
                                                       ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "print info,var[-1]" ),
                                                   ),
                                                   ValueSeriePrinter = BLOC (condition = " Template == 'ValueSeriePrinter' ",
                                                       ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "print info,var[:]" ),
                                                   ),
                                                   ValueSaver = BLOC (condition = " Template == 'ValueSaver' ",
                                                       ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "import numpy,re\\nv=numpy.array((var[-1]))\\nglobal istep\\ntry:\\n    istep += 1\\nexcept:\\n    istep = 0\\nf='/tmp/value_%s_%05i.txt'%(info,istep)\\nf=re.sub('\\s','_',f)\\nprint 'Value saved in \\"%s\\"'%f\\nnumpy.savetxt(f,v)" ),
                                                   ),
                                                   ValueSerieSaver = BLOC (condition = " Template == 'ValueSerieSaver' ",
                                                       ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "import numpy,re\\nv=numpy.array((var[:])) \\nglobal istep\\ntry:\\n    istep += 1\\nexcept:\\n    istep = 0\\nf='/tmp/value_%s_%05i.txt'%(info,istep)\\nf=re.sub('\\s','_',f)\\nprint 'Value saved in \\"%s\\"'%f\\nnumpy.savetxt(f,v)" ),
                                                   ),
                                                   ValuePrinterAndSaver = BLOC (condition = " Template == 'ValuePrinterAndSaver' ",
                                                       ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "import numpy,re\\nv=numpy.array((var[-1]))\\nprint info,v\\nglobal istep\\ntry:\\n    istep += 1\\nexcept:\\n    istep = 0\\nf='/tmp/value_%s_%05i.txt'%(info,istep)\\nf=re.sub('\\s','_',f)\\nprint 'Value saved in \\"%s\\"'%f\\nnumpy.savetxt(f,v)" ),
                                                   ),
                                                   ValueSeriePrinterAndSaver = BLOC (condition = " Template == 'ValueSeriePrinterAndSaver' ",
                                                       ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "import numpy,re\\nv=numpy.array((var[:])) \\nprint info,v\\nglobal istep\\ntry:\\n    istep += 1\\nexcept:\\n    istep = 0\\nf='/tmp/value_%s_%05i.txt'%(info,istep)\\nf=re.sub('\\s','_',f)\\nprint 'Value saved in \\"%s\\"'%f\\nnumpy.savetxt(f,v)" ),
                                                   ),
                                                   ValueGnuPlotter = BLOC (condition = " Template == 'ValueGnuPlotter' ",
                                                       ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "import Gnuplot\\nglobal ifig,gp\\ntry:\\n    ifig += 1\\n    gp('set style data lines')\\nexcept:\\n    ifig = 0\\n    gp = Gnuplot.Gnuplot(persist=1)\\n    gp('set style data lines')\\ngp('set title  \\"%s (Figure %i)\\"'%(info,ifig))\\ngp.plot( Gnuplot.Data( var[-1], with_='lines lw 2' ) )" ),
                                                   ),
                                                   ValueSerieGnuPlotter = BLOC (condition = " Template == 'ValueSerieGnuPlotter' ",
                                                       ValueTemplate = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "import Gnuplot\\nglobal ifig,gp\\ntry:\\n    ifig += 1\\n    gp('set style data lines')\\nexcept:\\n    ifig = 0\\n    gp = Gnuplot.Gnuplot(persist=1)\\n    gp('set style data lines')\\ngp('set title  \\"%s (Figure %i)\\"'%(info,ifig))\\ngp.plot( Gnuplot.Data( var[:], with_='lines lw 2' ) )" ),
                                                   ),
                                               ),
                                           ),
                                       ),
"""

observers_method = """
def F_Observers(statut) : return FACT(statut=statut,
                                      SELECTION = SIMP(statut="o", defaut=[], typ="TXM", min=0, max="**", validators=NoRepeat(), into=(${choices})),
${decl_choices}
                                     )
"""

assim_study = """

def F_variables(statut) : return FACT(statut=statut,
                                      regles = ( MEME_NOMBRE ('NAMES', 'SIZES')),
                                      NAMES = SIMP(statut="o", typ="TXM", max="**", validators=NoRepeat()),
                                      SIZES = SIMP(statut="o", typ="I", val_min=1, max="**")
                                      )

ASSIMILATION_STUDY = PROC(nom="ASSIMILATION_STUDY",
                          op=None,
                          repetable           = "n",
                          Study_name          = SIMP(statut="o", typ = "TXM", defaut="ADAO Calculation Case"),
                          Study_repertory     = SIMP(statut="f", typ = "Repertoire", min=1, max=1),
                          Debug               = SIMP(statut="f", typ = "I", into=(0, 1), defaut=0),
                          Algorithm           = SIMP(statut="o", typ = "TXM", into=(${algos_names})),
                          Background          = F_Background("o"),
                          BackgroundError     = F_BackgroundError("o"),
                          Observation         = F_Observation("o"),
                          ObservationError    = F_ObservationError("o"),
                          ObservationOperator = F_ObservationOperator("o"),
                          EvolutionModel      = F_EvolutionModel("f"),
                          EvolutionError      = F_EvolutionError("f"),
                          ControlInput        = F_ControlInput("f"),
                          AlgorithmParameters = F_AlgorithmParameters("f"),
                          UserDataInit        = F_Init("f"),
                          UserPostAnalysis    = F_UserPostAnalysis("f"),
                          InputVariables      = F_variables("f"),
                          OutputVariables     = F_variables("f"),
                          Observers           = F_Observers("f")
                         )

CHECKING_STUDY = PROC(nom="CHECKING_STUDY",
                          op=None,
                          repetable           = "n",
                          Study_name          = SIMP(statut="o", typ = "TXM", defaut="ADAO Checking Case"),
                          Study_repertory     = SIMP(statut="f", typ = "Repertoire", min=1, max=1),
                          Debug               = SIMP(statut="f", typ = "I", into=(0, 1), defaut=0),
                          Algorithm           = SIMP(statut="o", typ = "TXM", into=(${check_names})),
                          CheckingPoint       = F_CheckingPoint("o"),
                          ObservationOperator = F_ObservationOperator("o"),
                          AlgorithmParameters = F_AlgorithmParameters("f"),
                          UserDataInit        = F_Init("f"),
                         )
"""

begin_catalog_file = string.Template(begin_catalog_file)
data_method = string.Template(data_method)
assim_data_method = string.Template(assim_data_method)
assim_data_choice = string.Template(assim_data_choice)
assim_study = string.Template(assim_study)
observers_method = string.Template(observers_method)
observers_choice = string.Template(observers_choice)

#----------- End of Templates Part ---------------#



#----------- Begin generation script -----------#
print "-- Starting AdaoCalatogGenerator.py --"

try:
  import daEficas
  import daYacsSchemaCreator
  import daCore.AssimilationStudy
  import daYacsSchemaCreator.infos_daComposant as infos
except:
  logging.fatal("Import of ADAO python modules failed !" +
                "\n add ADAO python installation directory in your PYTHONPATH")
  traceback.print_exc()
  sys.exit(1)

def check_args(args):
  logging.debug("Arguments are :" + str(args))
  if len(args) != 2:
    logging.fatal("Bad number of arguments: you have to provide two arguments (%d given)" % (len(args)))
    sys.exit(1)

# Parse arguments
from optparse import OptionParser
usage = "usage: %prog [options] catalog_path catalog_name"
version="%prog 0.1"
my_parser = OptionParser(usage=usage, version=version)
(options, args) = my_parser.parse_args()
check_args(args)

catalog_path =  args[0]
catalog_name =  args[1]

# Generates into a string
mem_file = StringIO.StringIO()

# Start file
from time import strftime
mem_file.write(begin_catalog_file.substitute(date=strftime("%Y-%m-%d %H:%M:%S")))

# Step 1: A partir des infos, on cree les fonctions qui vont permettre
# d'entrer les donnees utilisateur
for data_input_name in infos.DataTypeDict.keys():
  logging.debug('A data input Type is found: ' + data_input_name)
  data_name = data_input_name
  data_into = ""
  data_default = ""

  # On recupere les differentes facon d'entrer les donnees
  for basic_type in infos.DataTypeDict[data_input_name]:
    data_into += "\"" + basic_type + "\", "

  # On choisit le default
  data_default = "\"" + infos.DataTypeDefaultDict[data_input_name] + "\""

  mem_file.write(data_method.substitute(data_name    = data_name,
                                        data_into    = data_into,
                                        data_default = data_default))

# Step 2: On cree les fonctions qui permettent de rentrer les donnees des algorithmes
for assim_data_input_name in infos.AssimDataDict.keys():
  logging.debug("An assimilation algorithm data input is found: " + assim_data_input_name)
  assim_name = assim_data_input_name
  storage = ""
  choices = ""
  default_choice = ""
  decl_choices = ""
  decl_opts = ""
  if infos.AssimDataDefaultDict[assim_data_input_name] in infos.StoredAssimData:
    storage = "                                          Stored = SIMP(statut=\"o\", typ = \"I\", into=(0, 1), defaut=0, fr=\"Choix de stockage interne ou non du concept parent\", ang=\"Choice of the storage or not of the parent concept\"),"
  for choice in infos.AssimDataDict[assim_data_input_name]:
    choices += "\"" + choice + "\", "
    decl_choices += assim_data_choice.substitute(choice_name = choice)
    if choice in infos.StoredAssimData:
      storage = "                                          Stored = SIMP(statut=\"o\", typ = \"I\", into=(0, 1), defaut=0, fr=\"Choix de stockage interne ou non du concept parent\", ang=\"Choice of the storage or not of the parent concept\"),"
  default_choice = "\"" + infos.AssimDataDefaultDict[assim_data_input_name] + "\""

  mem_file.write(assim_data_method.substitute(assim_name = assim_name,
                                              storage = storage,
                                              choices = choices,
                                              decl_choices = decl_choices,
                                              default_choice=default_choice))

# Step 3: On ajoute les fonctions representant les options possibles
for opt_name in infos.OptDict.keys():
  logging.debug("An optional node is found: " + opt_name)
  data_name = opt_name
  data_into = ""
  data_default = ""

  for choice in infos.OptDict[opt_name]:
    data_into += "\"" + choice + "\", "
  data_default = "\"" + infos.OptDefaultDict[opt_name] + "\""

  mem_file.write(data_method.substitute(data_name = data_name,
                                        data_into = data_into,
                                        data_default = data_default))

# Step 4: On ajoute la methode optionnelle init
# TODO uniformiser avec le step 3
mem_file.write(init_method)

# Step 5: Add observers
decl_choices = ""
for obs_var in infos.ObserversList:
  decl_choices += observers_choice.substitute(var_name=obs_var)
mem_file.write(observers_method.substitute(choices = infos.ObserversList,
                                           decl_choices = decl_choices))

# Final step: Add algorithm and assim_study
algos_names = ""
check_names = ""
decl_algos  = ""

assim_study_object = daCore.AssimilationStudy.AssimilationStudy()
algos_list = assim_study_object.get_available_algorithms()
for algo_name in algos_list:
  if algo_name in infos.AssimAlgos:
    logging.debug("An assimilation algorithm is found: " + algo_name)
    algos_names += "\"" + algo_name + "\", "
  elif algo_name in infos.CheckAlgos:
    logging.debug("A checking algorithm is found: " + algo_name)
    check_names += "\"" + algo_name + "\", "
  else:
    logging.debug("This algorithm is not considered: " + algo_name)

mem_file.write(assim_study.substitute(algos_names=algos_names,
                                      check_names=check_names,
                                      decl_algos=decl_algos))
# Write file
final_file = open(catalog_path + "/" + catalog_name, "wr")
final_file.write(mem_file.getvalue())
mem_file.close()
final_file.close()

