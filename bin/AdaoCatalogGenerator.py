#-*- coding:utf-8 -*-
#  Copyright (C) 2008-2011  EDF R&D
#
#  This library is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public
#  License as published by the Free Software Foundation; either
#  version 2.1 of the License.
#
#  This library is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with this library; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
#
# --
# Author : Andr√© RIBES (EDF R&D)
# --

import logging
import traceback
import sys
import string
import StringIO

logging.basicConfig(level=logging.INFO)

#----------- Templates Part ---------------#
begin_catalog_file = """# -*- coding: utf-8 -*-

# --------------------------------------------------------
# generated by AdaoCatalogGenerator at ${date}
# --------------------------------------------------------

import Accas
from Accas import *

JdC = JDC_CATA (code = 'ADAO',
                execmodul = None,
                regles = ( AU_MOINS_UN ('ASSIMILATION_STUDY','CHECKING_STUDY'), AU_PLUS_UN ('ASSIMILATION_STUDY','CHECKING_STUDY')),
               )
"""

data_method = """
def F_${data_name}(statut) : return FACT(statut = statut,
                                         FROM = SIMP(statut = "o", typ = "TXM", into=(${data_into}), defaut=${data_default}),
                                         SCRIPT_DATA = BLOC ( condition = " FROM in ( 'Script', ) ",

                                                      SCRIPT_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()), fr="En attente d'un nom de fichier script, avec ou sans le chemin complet pour le trouver, contenant la dÈfinition d'une variable interne de mÍme nom que le concept parent", ang="Waiting for a script file name, with or without the full path to find it, containing the definition of an internal variable of the same name as the parent concept"),
                                                     ),
                                         STRING_DATA = BLOC ( condition = " FROM in ( 'String', ) ",

                                                      STRING = SIMP(statut = "o", typ = "TXM", fr="En attente d'une chaine de caractËres entre guillements, qui soit valide pour construire un vecteur : une suite de nombres, utilisant un espace ou une virgule pour sÈparer deux ÈlÈments et un point-virgule pour sÈparer deux lignes", ang="Waiting for a string in quotes, valid to build a vector: a floats serie, using a space or comma to separate two elements in a line, a semi-colon to separate rows"),
                                                     ),
                                         SCRIPTWITHFUNCTIONS_DATA = BLOC ( condition = " FROM in ( 'ScriptWithFunctions', ) ",

                                                      SCRIPTWITHFUNCTIONS_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()), fr="En attente d'un nom de fichier script, avec ou sans le chemin complet pour le trouver, contenant en variables internes trois fonctions de calcul nommÈes DirectOperator, TangentOperator et AdjointOperator", ang="Waiting for a script file name, with or without the full path to find it, containing as internal variables three computation functions named DirectOperator, TangentOperator and AdjointOperator"),
                                                     ),
                                         SCRIPTWITHSWITCH_DATA = BLOC ( condition = " FROM in ( 'ScriptWithSwitch', ) ",

                                                      SCRIPTWITHSWITCH_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()), fr="En attente d'un nom de fichier script, avec ou sans le chemin complet pour le trouver, contenant un switch pour les calculs direct, tangent et adjoint", ang="Waiting for a script file name, with or without the full path to find it, containing a switch for direct, tangent and adjoint computations"),
                                                     ),
                                         FUNCTIONDICT_DATA = BLOC ( condition = " FROM in ( 'FunctionDict', ) ",

                                                      FUNCTIONDICT_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()), fr="OBSOLETE : conservÈ pour compatibilitÈ avec la version 6.5, sera supprimÈ dans le futur", ang="OBSOLETE: keeped for compatibility with the 6.5 version, will be removed in the future"),
                                                     ),
                                    )
"""

init_method = """
def F_InitChoice() : return  ("Background",
                              "BackgroundError",
                              "Observation",
                              "ObservationError",
                              "ObservationOperator",
                              "EvolutionModel",
                              "EvolutionError",
                              "AlgorithmParameters",
                              "UserPostAnalysis",
                             )

def F_Init(statut) : return FACT(statut = statut,
                                 INIT_FILE = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr())),
                                 TARGET_LIST = SIMP(statut = "o", typ = "TXM", min=1, max="**", into=F_InitChoice(),  validators=(VerifExiste(2))),
                                )
"""

assim_data_method = """
def F_${assim_name}(statut) : return FACT(statut=statut,
${storage}
                                          INPUT_TYPE = SIMP(statut="o", typ = "TXM", into=(${choices}), defaut=${default_choice}),
${decl_choices}
                                                )
"""

assim_data_choice = """
                                                 ${choice_name} = BLOC ( condition = " INPUT_TYPE in ( '${choice_name}', ) ",
                                                 data = F_${choice_name}("o"),
                                                 ),
"""

observers_choice = """
                                       ${var_name} = BLOC (condition=" '${var_name}' in set(SELECTION) ",
                                                  ${var_name}_data = FACT(statut = "o",
                                                             Scheduler = SIMP(statut = "f", typ = "TXM"),
                                                             Info      = SIMP(statut = "f", typ = "TXM"),
                                                             NodeType  = SIMP(statut = "o", typ = "TXM", min=1, max=1, defaut = "", into=("String", "Script")),
                                                             PythonScript = BLOC (condition = " NodeType == 'String' ",
                                                                                  Value = SIMP(statut = "o", typ = "TXM")
                                                                                 ),
                                                             UserFile = BLOC (condition = " NodeType == 'Script' ",
                                                                              Value = SIMP(statut = "o", typ = "FichierNoAbs", validators=(OnlyStr()))
                                                                             )
                                                                      ),
                                                          ),
"""

observers_method = """
def F_Observers(statut) : return FACT(statut=statut,
                                      SELECTION = SIMP(statut="o", defaut=[], typ="TXM", min=0, max="**", validators=NoRepeat(), into=(${choices})),
${decl_choices}
                                     )
"""

assim_study = """

def F_variables(statut) : return FACT(statut=statut,
                                      regles = ( MEME_NOMBRE ('NAMES', 'SIZES')),
                                      NAMES = SIMP(statut="o", typ="TXM", max="**", validators=NoRepeat()),
                                      SIZES = SIMP(statut="o", typ="I", val_min=1, max="**")
                                      )

ASSIMILATION_STUDY = PROC(nom="ASSIMILATION_STUDY",
                          op=None,
                          repetable           = "n",
                          Study_name          = SIMP(statut="o", typ = "TXM"),
                          Study_repertory     = SIMP(statut="f", typ = "TXM"),
                          Debug               = SIMP(statut="o", typ = "I", into=(0, 1), defaut=0),
                          Algorithm           = SIMP(statut="o", typ = "TXM", into=(${algos_names})),
                          Background          = F_Background("o"),
                          BackgroundError     = F_BackgroundError("o"),
                          Observation         = F_Observation("o"),
                          ObservationError    = F_ObservationError("o"),
                          ObservationOperator = F_ObservationOperator("o"),
                          EvolutionModel      = F_EvolutionModel("f"),
                          EvolutionError      = F_EvolutionError("f"),
                          AlgorithmParameters = F_AlgorithmParameters("f"),
                          UserDataInit        = F_Init("f"),
                          UserPostAnalysis    = F_UserPostAnalysis("f"),
                          InputVariables      = F_variables("f"),
                          OutputVariables     = F_variables("f"),
                          Observers           = F_Observers("f")
                         )

CHECKING_STUDY = PROC(nom="CHECKING_STUDY",
                          op=None,
                          repetable           = "n",
                          Study_name          = SIMP(statut="o", typ = "TXM"),
                          Study_repertory     = SIMP(statut="f", typ = "TXM"),
                          Debug               = SIMP(statut="o", typ = "I", into=(0, 1), defaut=0),
                          Algorithm           = SIMP(statut="o", typ = "TXM", into=(${check_names})),
                          CheckingPoint       = F_CheckingPoint("o"),
                          ObservationOperator = F_ObservationOperator("o"),
                          AlgorithmParameters = F_AlgorithmParameters("f"),
                          UserDataInit        = F_Init("f"),
                         )
"""

begin_catalog_file = string.Template(begin_catalog_file)
data_method = string.Template(data_method)
assim_data_method = string.Template(assim_data_method)
assim_data_choice = string.Template(assim_data_choice)
assim_study = string.Template(assim_study)
observers_method = string.Template(observers_method)
observers_choice = string.Template(observers_choice)

#----------- End of Templates Part ---------------#



#----------- Begin generation script -----------#
print "-- Starting AdaoCalatogGenerator.py --"

try:
  import daEficas
  import daYacsSchemaCreator
  import daCore.AssimilationStudy
  import daYacsSchemaCreator.infos_daComposant as infos
except:
  logging.fatal("Import of ADAO python modules failed !" +
                "\n add ADAO python installation directory in your PYTHONPATH")
  traceback.print_exc()
  sys.exit(1)

def check_args(args):
  logging.debug("Arguments are :" + str(args))
  if len(args) != 2:
    logging.fatal("Bad number of arguments: you have to provide two arguments (%d given)" % (len(args)))
    sys.exit(1)

# Parse arguments
from optparse import OptionParser
usage = "usage: %prog [options] catalog_path catalog_name"
version="%prog 0.1"
my_parser = OptionParser(usage=usage, version=version)
(options, args) = my_parser.parse_args()
check_args(args)

catalog_path =  args[0]
catalog_name =  args[1]

# Generates into a string
mem_file = StringIO.StringIO()

# Start file
from time import strftime
mem_file.write(begin_catalog_file.substitute(date=strftime("%Y-%m-%d %H:%M:%S")))

# Step 1: A partir des infos, on cr√©e les fonctions qui vont permettre
# d'entrer les donn√©es utilisateur
for data_input_name in infos.DataTypeDict.keys():
  logging.debug('A data input Type is found: ' + data_input_name)
  data_name = data_input_name
  data_into = ""
  data_default = ""

  # On r√©cup√®re les diff√©rentes fa√ßon d'entrer les donn√©es
  for basic_type in infos.DataTypeDict[data_input_name]:
    data_into += "\"" + basic_type + "\", "

  # On choisit le d√©fault
  data_default = "\"" + infos.DataTypeDefaultDict[data_input_name] + "\""

  mem_file.write(data_method.substitute(data_name    = data_name,
                                        data_into    = data_into,
                                        data_default = data_default))

# Step 2: On cr√©e les fonctions qui permettent de rentrer les donn√©es des algorithmes
for assim_data_input_name in infos.AssimDataDict.keys():
  logging.debug("An assimilation algorithm data input is found: " + assim_data_input_name)
  assim_name = assim_data_input_name
  storage = ""
  choices = ""
  default_choice = ""
  decl_choices = ""
  decl_opts = ""
  if infos.AssimDataDefaultDict[assim_data_input_name] in infos.StoredAssimData:
    storage = "                                          Stored = SIMP(statut=\"o\", typ = \"I\", into=(0, 1), defaut=0, fr=\"Choix de stockage interne ou non du concept parent\", ang=\"Choice of the storage or not of the parent concept\"),"
  for choice in infos.AssimDataDict[assim_data_input_name]:
    choices += "\"" + choice + "\", "
    decl_choices += assim_data_choice.substitute(choice_name = choice)
    if choice in infos.StoredAssimData:
      storage = "                                          Stored = SIMP(statut=\"o\", typ = \"I\", into=(0, 1), defaut=0, fr=\"Choix de stockage interne ou non du concept parent\", ang=\"Choice of the storage or not of the parent concept\"),"
  default_choice = "\"" + infos.AssimDataDefaultDict[assim_data_input_name] + "\""

  mem_file.write(assim_data_method.substitute(assim_name = assim_name,
                                              storage = storage,
                                              choices = choices,
                                              decl_choices = decl_choices,
                                              default_choice=default_choice))

# Step 3: On ajoute les fonctions repr√©sentant les options possibles
for opt_name in infos.OptDict.keys():
  logging.debug("An optional node is found: " + opt_name)
  data_name = opt_name
  data_into = ""
  data_default = ""

  for choice in infos.OptDict[opt_name]:
    data_into += "\"" + choice + "\", "
  data_default = "\"" + infos.OptDefaultDict[opt_name] + "\""

  mem_file.write(data_method.substitute(data_name = data_name,
                                        data_into = data_into,
                                        data_default = data_default))

# Step 4: On ajoute la m√©thode optionnelle init
# TODO uniformiser avec le step 3
mem_file.write(init_method)

# Step 5: Add observers
decl_choices = ""
for obs_var in infos.ObserversList:
  decl_choices += observers_choice.substitute(var_name=obs_var)
mem_file.write(observers_method.substitute(choices = infos.ObserversList,
                                           decl_choices = decl_choices))

# Final step: Add algorithm and assim_study
algos_names = ""
check_names = ""
decl_algos  = ""

assim_study_object = daCore.AssimilationStudy.AssimilationStudy()
algos_list = assim_study_object.get_available_algorithms()
for algo_name in algos_list:
  if algo_name in infos.AssimAlgos:
    logging.debug("An assimilation algorithm is found: " + algo_name)
    algos_names += "\"" + algo_name + "\", "
  elif algo_name in infos.CheckAlgos:
    logging.debug("A checking algorithm is found: " + algo_name)
    check_names += "\"" + algo_name + "\", "
  else:
    logging.debug("This algorithm is not considered: " + algo_name)

mem_file.write(assim_study.substitute(algos_names=algos_names,
                                      check_names=check_names,
                                      decl_algos=decl_algos))
# Write file
final_file = open(catalog_path + "/" + catalog_name, "wr")
final_file.write(mem_file.getvalue())
mem_file.close()
final_file.close()

